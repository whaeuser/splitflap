<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Authentic Split-Flap Display</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%);
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        .flip-board {
            background: linear-gradient(to bottom, #1a1a1a 0%, #0f0f0f 100%);
            padding: 4vw 6vw;
            border: 1.2vw solid #0a0a0a;
            border-radius: 2vw;
            box-shadow:
                0 2vw 6vw rgba(0, 0, 0, 0.8),
                inset 0 0 2vw rgba(0, 0, 0, 0.5),
                0 0 0 0.3vw #2a2a2a;
            position: relative;
            transform: perspective(150vw) rotateX(2deg);
            transform-style: preserve-3d;
        }

        /* Frame shadow to create depth */
        .flip-board::before {
            content: '';
            position: absolute;
            top: -1vw;
            left: -1vw;
            right: -1vw;
            bottom: -1vw;
            background: linear-gradient(135deg, rgba(40,40,40,0.4), rgba(10,10,10,0.8));
            border-radius: 2.5vw;
            z-index: -1;
            filter: blur(1vw);
        }

        .display-line {
            display: flex;
            justify-content: center;
            margin-bottom: 1vh;
            gap: 0.3vw;
        }

        .flip-char {
            width: 5.5vw;
            height: 8.25vw;
            position: relative;
            background: linear-gradient(to bottom, #1e1e1e 0%, #0e0e0e 100%);
            border: 0.15vw solid #222;
            border-radius: 0.6vw;
            overflow: hidden;
            margin: 0.15vw;
            perspective: 45vw;
            box-shadow:
                0 0.3vw 0.8vw rgba(0, 0, 0, 0.6),
                inset 0 0.1vw 0.2vw rgba(255, 255, 255, 0.05),
                inset 0 -0.1vw 0.2vw rgba(0, 0, 0, 0.5);
        }

        .flip-half {
            position: absolute;
            width: 100%;
            height: 50%;
            background: linear-gradient(to bottom, #2d2d2a 0%, #1d1d1a 100%);
            overflow: hidden;
            transform-style: preserve-3d;
            filter: brightness(0.95) contrast(1.05);
        }

        .flip-char-content {
            position: absolute;
            width: 100%;
            height: 8.25vw;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 7vw;
            font-weight: bold;
            color: #f5f5dc;
            text-align: center;
            line-height: 8.25vw;
            overflow: hidden;
            text-shadow:
                0 0.1vw 0.3vw rgba(0, 0, 0, 0.8),
                0 0 0.2vw rgba(245, 245, 220, 0.3);
            filter: brightness(0.98);
        }

        .flip-top {
            top: 0;
            transform-origin: bottom;
        }

        .flip-top .flip-char-content {
            top: 0;
            clip-path: inset(0 0 50% 0); /* Show only top half */
        }

        .flip-bottom {
            bottom: 0;
            background: linear-gradient(to bottom, #1a1a17 0%, #0a0a08 100%);
            transform-origin: top;
            filter: brightness(0.92) contrast(1.08);
        }

        .flip-bottom .flip-char-content {
            top: -4.125vw; /* Offset to show bottom half */
            clip-path: inset(50% 0 0 0); /* Show only bottom half */
        }

        .flip-top.flipping {
            animation: flipTop 0.3s ease-in forwards;
        }

        .flip-bottom.reveal {
            animation: flipBottom 0.3s ease-out 0.3s forwards;
            transform: rotateX(90deg);
        }

        @keyframes flipTop {
            0% { transform: rotateX(0deg); }
            100% { transform: rotateX(-90deg); }
        }

        @keyframes flipBottom {
            0% { transform: rotateX(90deg); }
            100% { transform: rotateX(0deg); }
        }

        /* Middle line separator */
        .flip-char::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 0.3vw;
            right: 0.3vw;
            height: 0.2vw;
            background: linear-gradient(to bottom, #1a1a1a, #0a0a0a, #1a1a1a);
            box-shadow:
                0 0 0.3vw rgba(0, 0, 0, 0.8),
                0 0.1vw 0.1vw rgba(0, 0, 0, 0.5);
            z-index: 10;
            transform: translateY(-0.1vw);
        }

        /* Enhanced glossy and wear effects */
        .flip-char::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background:
                linear-gradient(
                    135deg,
                    rgba(255,255,255,0.08) 0%,
                    transparent 15%,
                    transparent 85%,
                    rgba(0,0,0,0.25) 100%
                ),
                radial-gradient(
                    ellipse at 20% 30%,
                    rgba(255,255,255,0.12) 0%,
                    transparent 50%
                ),
                radial-gradient(
                    ellipse at 80% 70%,
                    rgba(0,0,0,0.15) 0%,
                    transparent 40%
                );
            pointer-events: none;
            z-index: 5;
        }

        .controls {
            margin-top: 30px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
        }

        .input-group {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
        }

        input {
            padding: 10px 15px;
            border: 2px solid #444;
            border-radius: 5px;
            background: #2a2a3e;
            color: white;
            font-size: 16px;
            min-width: 200px;
        }

        input:focus {
            outline: none;
            border-color: #ffd700;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.3);
        }

        button {
            background: linear-gradient(135deg, #ffd700, #ffed4e);
            color: #000;
            border: none;
            padding: 12px 25px;
            border-radius: 5px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        button:hover {
            background: linear-gradient(135deg, #ffed4e, #ffd700);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 215, 0, 0.4);
        }

        .preset-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .preset-btn {
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
            padding: 8px 16px;
            font-size: 14px;
        }

        .preset-btn:hover {
            background: linear-gradient(135deg, #45a049, #4CAF50);
        }

        .sound-toggle {
            background: linear-gradient(135deg, #9C27B0, #7B1FA2);
            color: white;
            padding: 8px 16px;
            font-size: 14px;
        }

        .sound-toggle:hover {
            background: linear-gradient(135deg, #7B1FA2, #9C27B0);
        }

        .sound-toggle.muted {
            background: linear-gradient(135deg, #666, #555);
        }

        @media (max-width: 768px) {
            .flip-char {
                width: 8vw;
                height: 12vw;
            }

            .flip-char-content {
                height: 12vw;
                font-size: 9vw;
                line-height: 12vw;
            }

            .flip-bottom .flip-char-content {
                top: -6vw;
            }

            /* Middle line separator for mobile */
            .flip-char::before {
                left: 0.4vw;
                right: 0.4vw;
                height: 0.2vw;
                transform: translateY(-0.1vw);
            }
        }

        .clicking {
            position: relative;
        }

        .clicking::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: rgba(255, 215, 0, 0.2);
            border-radius: 6px;
            animation: clickHighlight 0.6s ease-out;
            z-index: -1;
        }

        @keyframes clickHighlight {
            0% { opacity: 1; transform: scale(1); }
            100% { opacity: 0; transform: scale(1.1); }
        }
    </style>
</head>
<body>
    <div class="flip-board">
        <div class="display-line" id="line1"></div>
        <div class="display-line" id="line2"></div>
        <div class="display-line" id="line3"></div>
        <div class="display-line" id="line4"></div>
        <div class="display-line" id="line5"></div>
        <div class="display-line" id="line6"></div>
    </div>

    <!-- Hidden controls for API access -->
    <div class="controls" style="display: none;">
        <input type="text" id="textInput" placeholder="Text eingeben..." maxlength="16">
        <button class="sound-toggle" id="soundToggle" onclick="toggleSound()">ðŸ”Š Sound</button>
    </div>

    <script>
        const CHARACTERS = ' ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789:-./';

        // Color definitions
        const COLORS = {
            'blau': '#4A90E2',
            'hellblau': '#87CEEB',
            'rot': '#E74C3C',
            'gruen': '#2ECC71',
            'hellgruen': '#A8E6A1',
            'orange': '#FF8C42',
            'violett': '#9B59B6',
            'rosa': '#FFB6C1',
            'gelb': '#F1C40F',
            'weiss': '#FFFFFF',
            'default': '#FFFFFF'  // Default white color
        };

        let currentTexts = ['', '', '', '', '', ''];
        let currentColors = ['default', 'default', 'default', 'default', 'default', 'default'];
        let isAnimating = false;
        let soundEnabled = true;
        let audioContext = null;
        let datetimeMode = false;
        let datetimeInterval = null;

        // Scrolling and Marquee mode state
        let scrollingInterval = null;
        let scrollingLineIndex = null;
        let marqueeInterval = null;

        // Audio enhancement - convolver for reverb
        let reverbNode = null;
        let reverbEnabled = true;

        // Template and Scheduler system
        let templates = {};
        let scheduledTasks = [];
        let schedulerInterval = null;

        // Initialize audio context
        function initAudio() {
            if (!audioContext) {
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    createReverbEffect();
                } catch (e) {
                    console.log('Audio not supported');
                    soundEnabled = false;
                }
            }
        }

        // Create reverb effect using convolver
        function createReverbEffect() {
            if (!audioContext || reverbNode) return;

            try {
                reverbNode = audioContext.createConvolver();

                // Create impulse response for hall/station reverb
                const sampleRate = audioContext.sampleRate;
                const duration = 2.5; // 2.5 seconds reverb
                const decay = 3.5; // Decay rate
                const length = sampleRate * duration;
                const impulse = audioContext.createBuffer(2, length, sampleRate);

                const leftChannel = impulse.getChannelData(0);
                const rightChannel = impulse.getChannelData(1);

                for (let i = 0; i < length; i++) {
                    const n = i / sampleRate;
                    // Create realistic station hall reverb with early reflections
                    const envelope = Math.exp(-n * decay);

                    // Add some randomness for diffusion
                    const noise = (Math.random() * 2 - 1) * envelope;

                    // Early reflections (first 50ms)
                    const earlyReflections = i < sampleRate * 0.05 ?
                        Math.sin(i / 50) * envelope * 0.4 : 0;

                    leftChannel[i] = (noise + earlyReflections) * 0.5;
                    rightChannel[i] = (noise * 0.9 + earlyReflections * 1.1) * 0.5; // Slight stereo variation
                }

                reverbNode.buffer = impulse;
                console.log('Reverb effect created');
            } catch (e) {
                console.log('Reverb creation failed:', e);
                reverbNode = null;
            }
        }

        // Generate realistic mechanical click sound with variation and distance
        function playClickSound(charPosition = 0, linePosition = 0) {
            if (!soundEnabled) {
                console.log('Sound disabled');
                return;
            }

            if (!audioContext) {
                console.log('No audio context available');
                return;
            }

            if (audioContext.state === 'suspended') {
                console.log('Audio context suspended, trying to resume...');
                audioContext.resume().then(() => {
                    console.log('Audio context resumed, playing sound');
                    playActualSound(charPosition, linePosition);
                }).catch(e => {
                    console.log('Failed to resume audio context:', e);
                });
                return;
            }

            playActualSound(charPosition, linePosition);
        }

        function playActualSound(charPosition = 0, linePosition = 0) {
            try {
                const now = audioContext.currentTime;

                // Calculate position-based variations
                // Normalize positions: charPosition (0-15), linePosition (0-5)
                const horizontalPos = (charPosition - 7.5) / 7.5; // -1 to 1 (left to right)
                const verticalPos = (linePosition - 2.5) / 2.5; // -1 to 1 (top to bottom)

                // Distance from center (0 = center, 1 = corners)
                const distance = Math.sqrt(horizontalPos * horizontalPos + verticalPos * verticalPos) / Math.sqrt(2);

                // Random variation for each click (Â±5%)
                const randomVariation = 0.95 + Math.random() * 0.1;

                // Volume based on distance (closer = louder)
                const distanceVolume = 1 - (distance * 0.3); // 30% max reduction

                // Pitch variation based on position
                const pitchVariation = 0.95 + (Math.random() * 0.1); // Â±5% random pitch

                // Create master gain for this sound with reverb routing
                const masterGain = audioContext.createGain();
                const dryGain = audioContext.createGain();
                const wetGain = audioContext.createGain();

                // Route to dry output
                masterGain.connect(dryGain);
                dryGain.connect(audioContext.destination);
                dryGain.gain.setValueAtTime(0.7, now);

                // Route to reverb (wet) if available
                if (reverbNode && reverbEnabled) {
                    masterGain.connect(wetGain);
                    wetGain.connect(reverbNode);
                    reverbNode.connect(audioContext.destination);
                    wetGain.gain.setValueAtTime(0.25 * distanceVolume, now); // More reverb for distant sounds
                }

                // Create panner for stereo positioning
                const panner = audioContext.createStereoPanner();
                panner.pan.setValueAtTime(horizontalPos * 0.6, now); // 60% pan width

                // 1. Initial impact (sharp click) - with variation
                const impact = audioContext.createOscillator();
                const impactGain = audioContext.createGain();
                const impactFilter = audioContext.createBiquadFilter();

                impact.connect(impactFilter);
                impactFilter.connect(impactGain);
                impactGain.connect(panner);
                panner.connect(masterGain);

                impact.type = 'square';
                impact.frequency.setValueAtTime(800 * pitchVariation, now);
                impact.frequency.exponentialRampToValueAtTime(120 * pitchVariation, now + 0.015);

                impactFilter.type = 'highpass';
                impactFilter.frequency.setValueAtTime(400, now);

                impactGain.gain.setValueAtTime(0, now);
                impactGain.gain.linearRampToValueAtTime(0.12 * distanceVolume * randomVariation, now + 0.002);
                impactGain.gain.exponentialRampToValueAtTime(0.001, now + 0.025);

                impact.start(now);
                impact.stop(now + 0.025);

                // 2. Mechanical resonance (metallic ring) - with variation
                const resonance = audioContext.createOscillator();
                const resonanceGain = audioContext.createGain();
                const resonanceFilter = audioContext.createBiquadFilter();

                resonance.connect(resonanceFilter);
                resonanceFilter.connect(resonanceGain);
                resonanceGain.connect(panner);

                resonance.type = 'triangle';
                resonance.frequency.setValueAtTime(1800 * pitchVariation, now + 0.005);
                resonance.frequency.exponentialRampToValueAtTime(900 * pitchVariation, now + 0.04);

                resonanceFilter.type = 'bandpass';
                resonanceFilter.frequency.setValueAtTime(1500 * pitchVariation, now);
                resonanceFilter.Q.setValueAtTime(8, now);

                resonanceGain.gain.setValueAtTime(0, now + 0.005);
                resonanceGain.gain.linearRampToValueAtTime(0.06 * distanceVolume * randomVariation, now + 0.01);
                resonanceGain.gain.exponentialRampToValueAtTime(0.001, now + 0.06);

                resonance.start(now + 0.005);
                resonance.stop(now + 0.06);

                // 3. Damping noise (plastic/metal contact) - with variation
                const noise = audioContext.createOscillator();
                const noiseGain = audioContext.createGain();
                const noiseFilter = audioContext.createBiquadFilter();

                noise.connect(noiseFilter);
                noiseFilter.connect(noiseGain);
                noiseGain.connect(panner);

                noise.type = 'sawtooth';
                noise.frequency.setValueAtTime(350 * randomVariation, now + 0.01);
                noise.frequency.exponentialRampToValueAtTime(80 * randomVariation, now + 0.05);

                noiseFilter.type = 'lowpass';
                noiseFilter.frequency.setValueAtTime(600, now);
                noiseFilter.Q.setValueAtTime(1, now);

                noiseGain.gain.setValueAtTime(0, now + 0.01);
                noiseGain.gain.linearRampToValueAtTime(0.04 * distanceVolume * randomVariation, now + 0.015);
                noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.08);

                noise.start(now + 0.01);
                noise.stop(now + 0.08);

                // 4. Subtle motor/mechanism sound - with variation
                const motor = audioContext.createOscillator();
                const motorGain = audioContext.createGain();
                const motorFilter = audioContext.createBiquadFilter();

                motor.connect(motorFilter);
                motorFilter.connect(motorGain);
                motorGain.connect(panner);

                motor.type = 'sawtooth';
                motor.frequency.setValueAtTime(60 * randomVariation, now);
                motor.frequency.linearRampToValueAtTime(40 * randomVariation, now + 0.1);

                motorFilter.type = 'highpass';
                motorFilter.frequency.setValueAtTime(30, now);

                motorGain.gain.setValueAtTime(0, now);
                motorGain.gain.linearRampToValueAtTime(0.02 * distanceVolume, now + 0.02);
                motorGain.gain.exponentialRampToValueAtTime(0.001, now + 0.12);

                motor.start(now);
                motor.stop(now + 0.12);

            } catch (e) {
                console.log('Sound generation failed:', e);
            }
        }

        function toggleSound() {
            soundEnabled = !soundEnabled;
            const button = document.getElementById('soundToggle');
            
            if (soundEnabled) {
                initAudio();
                button.textContent = 'ðŸ”Š Sound';
                button.classList.remove('muted');
            } else {
                button.textContent = 'ðŸ”‡ Stumm';
                button.classList.add('muted');
            }
        }

        function createFlipChar(initialChar = ' ') {
            const char = document.createElement('div');
            char.className = 'flip-char';
            
            const topHalf = document.createElement('div');
            topHalf.className = 'flip-half flip-top';
            
            const topContent = document.createElement('div');
            topContent.className = 'flip-char-content';
            topContent.textContent = initialChar;
            topHalf.appendChild(topContent);
            
            const bottomHalf = document.createElement('div');
            bottomHalf.className = 'flip-half flip-bottom';
            
            const bottomContent = document.createElement('div');
            bottomContent.className = 'flip-char-content';
            bottomContent.textContent = initialChar;
            bottomHalf.appendChild(bottomContent);
            
            char.appendChild(topHalf);
            char.appendChild(bottomHalf);
            
            return char;
        }

        function initializeDisplay() {
            for (let lineNum = 1; lineNum <= 6; lineNum++) {
                const line = document.getElementById(`line${lineNum}`);
                line.innerHTML = '';

                for (let i = 0; i < 16; i++) {
                    line.appendChild(createFlipChar(' '));
                }
            }
            currentTexts = ['', '', '', '', '', ''];
        }

        function flipCharacter(charElement, newChar, delay = 0, charPosition = 0, linePosition = 0) {
            setTimeout(() => {
                const currentChar = charElement.querySelector('.flip-top .flip-char-content').textContent;

                // Skip if already showing the correct character
                if (currentChar === newChar) return;

                // Create mechanical sequence with intermediate characters
                const sequence = generateFlipSequence(currentChar, newChar);

                // Add visual effect for entire sequence
                charElement.classList.add('clicking');

                // Execute flip sequence with position info
                executeFlipSequence(charElement, sequence, charPosition, linePosition, () => {
                    charElement.classList.remove('clicking');
                });

            }, delay);
        }

        function generateFlipSequence(fromChar, toChar) {
            const fromIndex = CHARACTERS.indexOf(fromChar);
            const toIndex = CHARACTERS.indexOf(toChar);

            // If same character, no animation needed
            if (fromIndex === toIndex) return [];

            const sequence = [];
            let currentIndex = fromIndex;

            // Determine direction (forward or backward through alphabet)
            const forward = (toIndex - fromIndex + CHARACTERS.length) % CHARACTERS.length;
            const backward = (fromIndex - toIndex + CHARACTERS.length) % CHARACTERS.length;
            const useForward = forward <= backward;

            // Generate intermediate steps (3-6 flips for realism)
            const steps = Math.min(Math.max(3, Math.abs(toIndex - fromIndex)), 6);

            for (let i = 1; i <= steps; i++) {
                if (useForward) {
                    currentIndex = (fromIndex + Math.floor((forward * i) / steps)) % CHARACTERS.length;
                } else {
                    currentIndex = (fromIndex - Math.floor((backward * i) / steps) + CHARACTERS.length) % CHARACTERS.length;
                }

                sequence.push({
                    char: CHARACTERS[currentIndex],
                    duration: i === steps ? 300 : 150, // Last flip is slower
                    isLast: i === steps
                });
            }

            // Ensure final character is correct
            if (sequence[sequence.length - 1].char !== toChar) {
                sequence[sequence.length - 1].char = toChar;
            }

            return sequence;
        }

        function executeFlipSequence(charElement, sequence, charPosition, linePosition, onComplete) {
            if (sequence.length === 0) {
                onComplete();
                return;
            }

            let currentStep = 0;

            function doNextFlip() {
                if (currentStep >= sequence.length) {
                    onComplete();
                    return;
                }

                const step = sequence[currentStep];
                const topHalf = charElement.querySelector('.flip-top');
                const bottomHalf = charElement.querySelector('.flip-bottom');
                const topContent = topHalf.querySelector('.flip-char-content');
                const bottomContent = bottomHalf.querySelector('.flip-char-content');

                // Play click sound for each flip with position
                playClickSound(charPosition, linePosition);

                // Update the bottom content to new character (will be revealed)
                bottomContent.textContent = step.char;

                // Start flip animation with appropriate timing
                topHalf.style.animation = `flipTop ${step.duration}ms ease-in forwards`;
                bottomHalf.style.animation = `flipBottom ${step.duration}ms ease-out ${step.duration}ms forwards`;
                bottomHalf.style.transform = 'rotateX(90deg)';

                // After this flip completes, update top half and continue
                setTimeout(() => {
                    topContent.textContent = step.char;

                    // Reset animations
                    topHalf.style.animation = '';
                    bottomHalf.style.animation = '';
                    bottomHalf.style.transform = '';

                    currentStep++;

                    // Small pause between flips for realism
                    setTimeout(doNextFlip, step.isLast ? 0 : 50);

                }, step.duration * 2);
            }

            doNextFlip();
        }

        function setLineColor(lineIndex, colorName) {
            if (lineIndex < 0 || lineIndex >= 6) return;

            const normalizedColor = colorName ? colorName.toLowerCase() : 'default';
            const color = COLORS[normalizedColor] || COLORS['default'];
            currentColors[lineIndex] = normalizedColor;

            const line = document.getElementById(`line${lineIndex + 1}`);
            const chars = line.querySelectorAll('.flip-char-content');

            chars.forEach(char => {
                char.style.color = color;
            });
        }

        function updateLine(lineIndex, newText, startDelay = 0, colorName = null) {
            const line = document.getElementById(`line${lineIndex + 1}`);
            const chars = line.querySelectorAll('.flip-char');

            newText = newText.toUpperCase().padEnd(16, ' ').substring(0, 16);
            const oldText = currentTexts[lineIndex].padEnd(16, ' ').substring(0, 16);

            // Only flip characters that actually changed
            chars.forEach((char, index) => {
                if (newText[index] !== oldText[index]) {
                    flipCharacter(char, newText[index], startDelay + index * 80, index, lineIndex);
                }
            });

            currentTexts[lineIndex] = newText.trimEnd();

            // Set color if provided
            if (colorName !== null) {
                setLineColor(lineIndex, colorName);
            }
        }

        function updateDisplay() {
            if (isAnimating) return;
            
            const input = document.getElementById('textInput');
            const text = input.value.trim();
            
            if (text) {
                isAnimating = true;
                updateLine(1, text);
                
                setTimeout(() => {
                    isAnimating = false;
                }, 2500);
            }
        }

        function clearDisplay() {
            // Stoppe Demo falls lÃ¤uft
            stopDemo();

            if (isAnimating) return;

            isAnimating = true;
            updateLine(0, '');
            updateLine(1, '');
            updateLine(2, '');
            updateLine(3, '');
            updateLine(4, '');
            updateLine(5, '');

            setTimeout(() => {
                isAnimating = false;
            }, 2500);
        }

        function setPreset(text) {
            document.getElementById('textInput').value = text;
            updateDisplay();
        }

        let demoRunning = false;
        let demoTimeout = null;

        function startDemo() {
            // Stoppe vorherige Demo falls lÃ¤uft
            stopDemo();

            demoRunning = true;
            isAnimating = true;

            const demoSequence = [
                {
                    lines: ['FLUGHAFEN', 'MUENCHEN', 'TERMINAL 2', 'ABFLUG', 'GATE A15', '12:30'],
                    colors: ['blau', 'hellblau', 'gruen', 'orange', 'gelb', 'gruen']
                },
                {
                    lines: ['LH 441', 'NACH FRANKFURT', 'BOARDING NOW', 'GATE B7', 'PÃœNKTLICH', ''],
                    colors: ['blau', 'hellblau', 'orange', 'gelb', 'gruen', null]
                },
                {
                    lines: ['AIR FRANCE', 'NACH PARIS', 'VERSPAETUNG', '+25 MINUTEN', 'GATE C3', '14:45'],
                    colors: ['blau', 'hellblau', 'rot', 'rot', 'orange', 'gelb']
                },
                {
                    lines: ['LUFTHANSA', 'NACH BERLIN', 'LETZTER AUFRUF', 'GATE A2', 'SOFORT', ''],
                    colors: ['blau', 'hellblau', 'orange', 'gelb', 'rot', null]
                },
                {
                    lines: ['GUTEN FLUG', 'AUF WIEDERSEHEN', 'DANKE', 'SCHÃ–NEN TAG', '', ''],
                    colors: ['gruen', 'hellblau', 'violett', 'rosa', null, null]
                }
            ];

            let step = 0;

            function nextDemoStep() {
                if (!demoRunning) {
                    isAnimating = false;
                    return;
                }

                const { lines, colors } = demoSequence[step];

                updateLine(0, lines[0], 0, colors[0]);
                updateLine(1, lines[1], 200, colors[1]);
                updateLine(2, lines[2], 400, colors[2]);
                updateLine(3, lines[3], 600, colors[3]);
                updateLine(4, lines[4], 800, colors[4]);
                updateLine(5, lines[5], 1000, colors[5]);

                step++;

                // ZurÃ¼ck zum Anfang wenn alle Szenen durch sind (Endlosschleife)
                if (step >= demoSequence.length) {
                    step = 0;
                }

                // NÃ¤chste Szene nach 5 Sekunden
                demoTimeout = setTimeout(nextDemoStep, 5000);
            }

            nextDemoStep();
        }

        function stopDemo() {
            demoRunning = false;
            if (demoTimeout) {
                clearTimeout(demoTimeout);
                demoTimeout = null;
            }
            isAnimating = false;
        }

        // Event Listeners
        document.getElementById('textInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                updateDisplay();
            }
        });

        // Enable audio immediately or on first interaction
        function ensureAudioContext() {
            if (soundEnabled && !audioContext) {
                initAudio();
            }
        }

        // Try to enable audio immediately
        function tryEnableAudioImmediately() {
            if (!soundEnabled) return;

            // iOS Safari requires user interaction, set up listeners immediately
            if (navigator.userAgent.includes('Safari') && navigator.userAgent.includes('Mobile')) {
                console.log('iOS Safari detected, setting up touch listeners');
                setupUserInteractionListeners();
                return;
            }

            try {
                // Try to create audio context immediately for desktop
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    console.log('Audio context created immediately');
                }

                // Test if audio context is allowed to start
                if (audioContext.state === 'suspended') {
                    audioContext.resume().then(() => {
                        console.log('Audio context resumed successfully');
                    }).catch(() => {
                        console.log('Audio context resume failed, waiting for user interaction');
                        setupUserInteractionListeners();
                    });
                }
            } catch (e) {
                console.log('Immediate audio failed:', e.message, 'waiting for user interaction');
                setupUserInteractionListeners();
            }
        }

        function setupUserInteractionListeners() {
            function enableAudioOnInteraction(event) {
                console.log('User interaction detected:', event.type);

                if (!audioContext) {
                    try {
                        audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        console.log('Audio context created on user interaction');
                    } catch (e) {
                        console.log('Failed to create audio context:', e);
                        return;
                    }
                }

                if (audioContext.state === 'suspended') {
                    audioContext.resume().then(() => {
                        console.log('Audio context resumed on user interaction');
                        // Test sound to confirm it works
                        setTimeout(() => {
                            if (soundEnabled) {
                                console.log('Playing test sound');
                                playActualSound();
                            }
                        }, 100);
                    }).catch((e) => {
                        console.log('Failed to resume audio context:', e);
                    });
                }

                // Remove listeners after successful activation
                document.removeEventListener('click', enableAudioOnInteraction);
                document.removeEventListener('keydown', enableAudioOnInteraction);
                document.removeEventListener('touchstart', enableAudioOnInteraction);
                document.removeEventListener('touchend', enableAudioOnInteraction);

                console.log('Audio interaction listeners removed');
            }

            // Add comprehensive interaction listeners for iOS
            document.addEventListener('click', enableAudioOnInteraction, { passive: true });
            document.addEventListener('keydown', enableAudioOnInteraction, { passive: true });
            document.addEventListener('touchstart', enableAudioOnInteraction, { passive: true });
            document.addEventListener('touchend', enableAudioOnInteraction, { passive: true });

            console.log('Audio interaction listeners added');
        }

        // DateTime functions
        function formatDateTime() {
            const now = new Date();

            // Format date as DD.MM.YYYY (10 chars)
            const day = String(now.getDate()).padStart(2, '0');
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const year = now.getFullYear();
            const dateStr = `${day}.${month}.${year}`;

            // Format time as HH:MM (5 chars - without seconds to fit)
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const timeStr = `${hours}:${minutes}`;

            // Total: 10 (date) + 1 (space) + 5 (time) = 16 chars
            const topLine = `${dateStr} ${timeStr}`;

            return topLine; // Returns exactly 16 characters: "11.11.2025 18:14"
        }

        function startDateTimeMode() {
            if (datetimeInterval) {
                clearInterval(datetimeInterval);
            }

            datetimeMode = true;
            console.log('DateTime mode enabled');

            // Update immediately
            updateDateTimeDisplay();

            // Update every second
            datetimeInterval = setInterval(updateDateTimeDisplay, 1000);
        }

        function stopDateTimeMode() {
            if (datetimeInterval) {
                clearInterval(datetimeInterval);
                datetimeInterval = null;
            }

            datetimeMode = false;
            console.log('DateTime mode disabled');
        }

        // Scrolling text mode - scrolls long text on a single line
        function startScrollingMode(lineIndex, text, speed = 500) {
            // Stop any existing scrolling
            stopScrollingMode();

            if (!text || text.trim() === '') {
                console.warn('No text provided for scrolling');
                return;
            }

            // Ensure text is at least 16 characters for smooth scrolling
            const paddedText = text.toUpperCase() + '        '; // Add spacing
            scrollingLineIndex = lineIndex;

            let position = 0;

            function scroll() {
                const displayText = paddedText.substring(position, position + 16);
                updateLine(lineIndex, displayText.padEnd(16, ' '));

                position++;
                if (position >= paddedText.length) {
                    position = 0;
                }
            }

            // Initial display
            scroll();

            // Start scrolling interval
            scrollingInterval = setInterval(scroll, speed);
            console.log(`Scrolling mode started on line ${lineIndex} with text: "${text}"`);
        }

        function stopScrollingMode() {
            if (scrollingInterval) {
                clearInterval(scrollingInterval);
                scrollingInterval = null;
                scrollingLineIndex = null;
                console.log('Scrolling mode stopped');
            }
        }

        // Marquee mode - scrolls text vertically across all lines
        function startMarqueeMode(text, speed = 300) {
            // Stop any existing marquee
            stopMarqueeMode();

            if (!text || text.trim() === '') {
                console.warn('No text provided for marquee');
                return;
            }

            // Split text into words and create scrolling lines
            const words = text.toUpperCase().split(' ');
            const lines = [];
            let currentLine = '';

            // Build lines from words (max 16 chars per line)
            words.forEach(word => {
                if ((currentLine + ' ' + word).trim().length <= 16) {
                    currentLine = (currentLine + ' ' + word).trim();
                } else {
                    if (currentLine) lines.push(currentLine.padEnd(16, ' '));
                    currentLine = word;
                }
            });
            if (currentLine) lines.push(currentLine.padEnd(16, ' '));

            // Add empty lines for smooth scrolling
            for (let i = 0; i < 6; i++) {
                lines.push(''.padEnd(16, ' '));
            }

            let position = 0;

            function marquee() {
                for (let i = 0; i < 6; i++) {
                    const lineIndex = (position + i) % lines.length;
                    updateLine(i, lines[lineIndex]);
                }

                position++;
                if (position >= lines.length) {
                    position = 0;
                }
            }

            // Initial display
            marquee();

            // Start marquee interval
            marqueeInterval = setInterval(marquee, speed);
            console.log(`Marquee mode started with ${lines.length} lines`);
        }

        function stopMarqueeMode() {
            if (marqueeInterval) {
                clearInterval(marqueeInterval);
                marqueeInterval = null;
                console.log('Marquee mode stopped');
            }
        }

        // Stop all animated modes
        function stopAllAnimatedModes() {
            stopDateTimeMode();
            stopScrollingMode();
            stopMarqueeMode();
            console.log('All animated modes stopped');
        }

        function updateDateTimeDisplay() {
            if (!datetimeMode) return;

            const dateTimeStr = formatDateTime();

            // Only update if different from current content to avoid unnecessary animations
            if (currentTexts[0] !== dateTimeStr) {
                updateLine(0, dateTimeStr, 0, null);
            }
        }

        // ====== TEMPLATE SYSTEM ======

        // Built-in templates
        const builtInTemplates = {
            'airport-arrival': {
                name: 'Airport Arrival',
                description: 'Airport arrival information',
                lines: [
                    'FLUGHAFEN {{airport}}',
                    '{{airline}} {{flightno}}',
                    'ANKUNFT {{time}}',
                    'VON {{origin}}',
                    'GATE {{gate}}',
                    '{{status}}'
                ]
            },
            'airport-departure': {
                name: 'Airport Departure',
                description: 'Airport departure information',
                lines: [
                    'FLUGHAFEN {{airport}}',
                    '{{airline}} {{flightno}}',
                    'ABFLUG {{time}}',
                    'NACH {{destination}}',
                    'GATE {{gate}}',
                    '{{status}}'
                ]
            },
            'train-departure': {
                name: 'Train Departure',
                description: 'Train departure board',
                lines: [
                    '{{time}} {{platform}}',
                    '{{traintype}} {{trainno}}',
                    'NACH {{destination}}',
                    'ÃœBER {{via}}',
                    '{{status}}',
                    ''
                ]
            },
            'welcome': {
                name: 'Welcome Message',
                description: 'Simple welcome message',
                lines: [
                    '{{line1}}',
                    '{{line2}}',
                    '{{line3}}',
                    '{{line4}}',
                    '{{line5}}',
                    '{{line6}}'
                ]
            },
            'clock': {
                name: 'Date and Time',
                description: 'Shows current date and time',
                lines: [
                    '{{datetime}}',
                    '',
                    '',
                    '',
                    '',
                    ''
                ]
            }
        };

        // Initialize templates with built-in ones
        templates = { ...builtInTemplates };

        // Render template with data
        function renderTemplate(templateName, data) {
            const template = templates[templateName];
            if (!template) {
                console.error(`Template "${templateName}" not found`);
                return null;
            }

            // Special handling for datetime
            if (data.datetime === true) {
                data.datetime = formatDateTime();
            }

            const renderedLines = template.lines.map(line => {
                let rendered = line;
                // Replace all {{variable}} placeholders
                Object.keys(data).forEach(key => {
                    const placeholder = `{{${key}}}`;
                    rendered = rendered.replace(new RegExp(placeholder, 'g'), data[key] || '');
                });
                return rendered;
            });

            return renderedLines;
        }

        // Add or update template
        function addTemplate(name, templateData) {
            templates[name] = {
                name: templateData.name || name,
                description: templateData.description || '',
                lines: templateData.lines || ['', '', '', '', '', '']
            };
            console.log(`Template "${name}" added/updated`);
        }

        // Get template
        function getTemplate(name) {
            return templates[name] || null;
        }

        // List all templates
        function listTemplates() {
            return Object.keys(templates).map(key => ({
                id: key,
                name: templates[key].name,
                description: templates[key].description
            }));
        }

        // Display using template
        function displayTemplate(templateName, data = {}) {
            const lines = renderTemplate(templateName, data);
            if (!lines) return;

            if (datetimeMode) {
                stopDateTimeMode();
            }

            ensureAudioContext();
            isAnimating = true;

            updateLine(0, lines[0], 0);
            updateLine(1, lines[1], 200);
            updateLine(2, lines[2], 400);
            updateLine(3, lines[3], 600);
            updateLine(4, lines[4], 800);
            updateLine(5, lines[5], 1000);

            setTimeout(() => { isAnimating = false; }, 3500);
        }

        // ====== SCHEDULER SYSTEM ======

        // Start scheduler (checks every second)
        function startScheduler() {
            if (schedulerInterval) return;

            schedulerInterval = setInterval(() => {
                checkScheduledTasks();
            }, 1000);

            console.log('Scheduler started');
        }

        // Stop scheduler
        function stopScheduler() {
            if (schedulerInterval) {
                clearInterval(schedulerInterval);
                schedulerInterval = null;
                console.log('Scheduler stopped');
            }
        }

        // Check and execute scheduled tasks
        function checkScheduledTasks() {
            const now = new Date();
            const currentTime = now.getHours() * 3600 + now.getMinutes() * 60 + now.getSeconds();
            const currentDay = now.getDay(); // 0 = Sunday, 6 = Saturday

            scheduledTasks.forEach((task, index) => {
                if (!task.enabled) return;

                // Check if task should run
                let shouldRun = false;

                if (task.type === 'time') {
                    // Daily at specific time
                    const taskTime = task.hour * 3600 + task.minute * 60;
                    shouldRun = currentTime === taskTime;

                    // Check days of week if specified
                    if (shouldRun && task.days && task.days.length > 0) {
                        shouldRun = task.days.includes(currentDay);
                    }
                } else if (task.type === 'interval') {
                    // Interval-based
                    if (!task.lastRun) {
                        shouldRun = true;
                    } else {
                        const elapsed = now.getTime() - task.lastRun;
                        shouldRun = elapsed >= task.interval;
                    }
                }

                if (shouldRun) {
                    console.log(`Executing scheduled task: ${task.name}`);
                    executeScheduledTask(task);
                    task.lastRun = now.getTime();
                }
            });
        }

        // Execute a scheduled task
        function executeScheduledTask(task) {
            if (task.action === 'template') {
                displayTemplate(task.template, task.data || {});
            } else if (task.action === 'display') {
                window.splitflapAPI.setDisplay(
                    task.lines[0], task.lines[1], task.lines[2],
                    task.lines[3], task.lines[4], task.lines[5]
                );
            } else if (task.action === 'datetime') {
                window.splitflapAPI.datetime(true);
            } else if (task.action === 'clear') {
                window.splitflapAPI.clear();
            } else if (task.action === 'demo') {
                window.splitflapAPI.demo();
            } else if (task.action === 'custom' && task.callback) {
                task.callback();
            }
        }

        // Add scheduled task
        function scheduleTask(taskConfig) {
            const task = {
                id: taskConfig.id || `task_${Date.now()}`,
                name: taskConfig.name || 'Unnamed Task',
                enabled: taskConfig.enabled !== false,
                type: taskConfig.type || 'time', // 'time' or 'interval'
                action: taskConfig.action, // 'template', 'display', 'datetime', 'clear', 'demo', 'custom'
                ...taskConfig
            };

            // Validate task
            if (task.type === 'time' && (task.hour === undefined || task.minute === undefined)) {
                console.error('Time-based tasks require hour and minute');
                return null;
            }

            if (task.type === 'interval' && !task.interval) {
                console.error('Interval-based tasks require interval in milliseconds');
                return null;
            }

            // Remove existing task with same ID
            scheduledTasks = scheduledTasks.filter(t => t.id !== task.id);

            // Add task
            scheduledTasks.push(task);
            console.log(`Scheduled task added: ${task.name}`, task);

            // Start scheduler if not running
            if (!schedulerInterval) {
                startScheduler();
            }

            return task.id;
        }

        // Remove scheduled task
        function removeScheduledTask(taskId) {
            scheduledTasks = scheduledTasks.filter(t => t.id !== taskId);
            console.log(`Scheduled task removed: ${taskId}`);

            // Stop scheduler if no tasks
            if (scheduledTasks.length === 0) {
                stopScheduler();
            }
        }

        // Enable/disable scheduled task
        function toggleScheduledTask(taskId, enabled) {
            const task = scheduledTasks.find(t => t.id === taskId);
            if (task) {
                task.enabled = enabled;
                console.log(`Task ${taskId} ${enabled ? 'enabled' : 'disabled'}`);
            }
        }

        // List all scheduled tasks
        function listScheduledTasks() {
            return scheduledTasks.map(t => ({
                id: t.id,
                name: t.name,
                type: t.type,
                enabled: t.enabled,
                action: t.action
            }));
        }

        // Clear all scheduled tasks
        function clearScheduledTasks() {
            scheduledTasks = [];
            stopScheduler();
            console.log('All scheduled tasks cleared');
        }

        // API Functions
        window.splitflapAPI = {
            // Set text on a specific line (0-5) with optional color
            setLine: function(lineIndex, text, color = null) {
                // Stoppe Demo falls lÃ¤uft
                stopDemo();

                if (lineIndex >= 0 && lineIndex <= 5 && !isAnimating) {
                    // Prevent overwriting line 0 if datetime mode is active
                    if (lineIndex === 0 && datetimeMode) {
                        console.warn('Cannot overwrite line 0 while datetime mode is active');
                        return;
                    }
                    updateLine(lineIndex, text, 0, color);
                }
            },

            // Set all lines at once with optional colors
            setDisplay: function(line1 = '', line2 = '', line3 = '', line4 = '', line5 = '', line6 = '',
                                color1 = null, color2 = null, color3 = null, color4 = null, color5 = null, color6 = null) {
                // Stoppe Demo falls lÃ¤uft
                stopDemo();

                if (!isAnimating) {
                    ensureAudioContext(); // Ensure audio works for API calls
                    isAnimating = true;

                    // Skip line 0 if datetime mode is active, otherwise update it
                    if (!datetimeMode) {
                        updateLine(0, line1, 0, color1);
                    }

                    updateLine(1, line2, 200, color2);
                    updateLine(2, line3, 400, color3);
                    updateLine(3, line4, 600, color4);
                    updateLine(4, line5, 800, color5);
                    updateLine(5, line6, 1000, color6);
                    setTimeout(() => { isAnimating = false; }, 3500);
                }
            },

            // Set color for a specific line
            setLineColor: function(lineIndex, colorName) {
                if (lineIndex >= 0 && lineIndex <= 5) {
                    setLineColor(lineIndex, colorName);
                }
            },

            // Get available colors
            getColors: function() {
                return Object.keys(COLORS).filter(c => c !== 'default');
            },

            // Clear all lines
            clear: function() {
                if (datetimeMode) {
                    stopDateTimeMode();
                }
                ensureAudioContext(); // Ensure audio works for API calls
                clearDisplay();
            },

            // Start demo sequence
            demo: function() {
                if (datetimeMode) {
                    stopDateTimeMode();
                }
                ensureAudioContext(); // Ensure audio works for API calls
                startDemo();
            },

            // Enable/disable datetime mode
            datetime: function(enable = true) {
                if (enable) {
                    startDateTimeMode();
                } else {
                    stopDateTimeMode();
                }
            },

            // Toggle sound
            toggleSound: function() {
                toggleSound();
            },

            // Get current display state
            getCurrentDisplay: function() {
                return [...currentTexts];
            },

            // Check if animation is running
            isAnimating: function() {
                return isAnimating;
            },

            // Check if datetime mode is active
            isDateTimeMode: function() {
                return datetimeMode;
            },

            // Start scrolling text on a specific line
            startScrolling: function(lineIndex, text, speed = 500) {
                if (lineIndex >= 0 && lineIndex <= 5) {
                    startScrollingMode(lineIndex, text, speed);
                }
            },

            // Start marquee text across all lines
            startMarquee: function(text, speed = 300) {
                startMarqueeMode(text, speed);
            },

            // Stop all animated modes
            stopAllModes: function() {
                stopAllAnimatedModes();
            },

            // ====== TEMPLATE API ======

            // Display content using a template
            displayTemplate: function(templateName, data = {}) {
                displayTemplate(templateName, data);
            },

            // Add or update a template
            addTemplate: function(name, templateData) {
                addTemplate(name, templateData);
            },

            // Get a template
            getTemplate: function(name) {
                return getTemplate(name);
            },

            // List all available templates
            listTemplates: function() {
                return listTemplates();
            },

            // ====== SCHEDULER API ======

            // Schedule a task
            schedule: function(taskConfig) {
                return scheduleTask(taskConfig);
            },

            // Remove a scheduled task
            removeSchedule: function(taskId) {
                removeScheduledTask(taskId);
            },

            // Enable/disable a scheduled task
            toggleSchedule: function(taskId, enabled) {
                toggleScheduledTask(taskId, enabled);
            },

            // List all scheduled tasks
            listSchedules: function() {
                return listScheduledTasks();
            },

            // Clear all scheduled tasks
            clearSchedules: function() {
                clearScheduledTasks();
            },

            // Start the scheduler manually
            startScheduler: function() {
                startScheduler();
            },

            // Stop the scheduler
            stopScheduler: function() {
                stopScheduler();
            }
        };

        // HTTP API via URL parameters
        function handleURLParams() {
            const params = new URLSearchParams(window.location.search);

            // Check sound parameter
            if (params.has('sound')) {
                const soundParam = params.get('sound').toLowerCase();
                soundEnabled = soundParam !== 'false' && soundParam !== '0' && soundParam !== 'off';

                // Update sound toggle button if it exists
                const soundToggle = document.getElementById('soundToggle');
                if (soundToggle) {
                    if (soundEnabled) {
                        soundToggle.textContent = 'ðŸ”Š Sound';
                        soundToggle.classList.remove('muted');
                    } else {
                        soundToggle.textContent = 'ðŸ”‡ Stumm';
                        soundToggle.classList.add('muted');
                    }
                }
            }

            if (params.has('line1') || params.has('line2') || params.has('line3') ||
                params.has('line4') || params.has('line5') || params.has('line6')) {
                const line1 = params.get('line1') || '';
                const line2 = params.get('line2') || '';
                const line3 = params.get('line3') || '';
                const line4 = params.get('line4') || '';
                const line5 = params.get('line5') || '';
                const line6 = params.get('line6') || '';

                setTimeout(() => {
                    window.splitflapAPI.setDisplay(line1, line2, line3, line4, line5, line6);
                }, 1000);
            } else if (params.has('demo')) {
                setTimeout(() => {
                    window.splitflapAPI.demo();
                }, 1000);
            } else if (params.has('clear')) {
                setTimeout(() => {
                    window.splitflapAPI.clear();
                }, 1000);
            }
        }

        // HTTP API server communication via polling
        function connectToServer() {
            function pollCommands() {
                fetch('/api/commands')
                    .then(response => response.json())
                    .then(data => {
                        if (data.action === 'setDisplay') {
                            console.log('Received setDisplay command:', data);
                            window.splitflapAPI.setDisplay(
                                data.line1, data.line2, data.line3,
                                data.line4, data.line5, data.line6,
                                data.color1, data.color2, data.color3,
                                data.color4, data.color5, data.color6
                            );
                        } else if (data.action === 'clear') {
                            console.log('Received clear command');
                            window.splitflapAPI.clear();
                        } else if (data.action === 'demo') {
                            console.log('Received demo command');
                            window.splitflapAPI.demo();
                        } else if (data.action === 'datetime') {
                            console.log('Received datetime command:', data.enable);
                            window.splitflapAPI.datetime(data.enable);
                        }
                    })
                    .catch(error => {
                        console.error('Error polling commands:', error);
                    });

                // Poll every 500ms
                setTimeout(pollCommands, 500);
            }

            // Start polling
            pollCommands();
        }

        // PostMessage API for iframe communication
        window.addEventListener('message', function(event) {
            const { action, data, command, params } = event.data;

            console.log('Received postMessage:', event.data);

            switch (action) {
                case 'setDisplay':
                    window.splitflapAPI.setDisplay(
                        data.line1, data.line2, data.line3,
                        data.line4, data.line5, data.line6,
                        data.color1, data.color2, data.color3,
                        data.color4, data.color5, data.color6
                    );
                    break;
                case 'setLine':
                    window.splitflapAPI.setLine(data.lineIndex, data.text, data.color);
                    break;
                case 'clear':
                    window.splitflapAPI.clear();
                    break;
                case 'demo':
                    window.splitflapAPI.demo();
                    break;
                case 'toggleSound':
                    window.splitflapAPI.toggleSound();
                    break;
                case 'getState':
                    event.source.postMessage({
                        type: 'splitflapState',
                        display: window.splitflapAPI.getCurrentDisplay(),
                        isAnimating: window.splitflapAPI.isAnimating()
                    }, event.origin);
                    break;
                case 'customCommand':
                    // Handle custom commands from admin UI
                    console.log('Custom command:', command, params);
                    if (command && window.splitflapAPI[command]) {
                        console.log('Executing command:', command);
                        window.splitflapAPI[command](...(params || []));
                    } else {
                        console.error('Command not found:', command, 'Available:', Object.keys(window.splitflapAPI));
                    }
                    break;
            }
        });

        // Add iOS-specific audio unlock button
        function createAudioUnlockButton() {
            if (navigator.userAgent.includes('Safari') && navigator.userAgent.includes('Mobile')) {
                const button = document.createElement('div');
                button.id = 'ios-audio-unlock';
                button.innerHTML = 'ðŸ”Š Touch to Enable Sound';
                button.style.cssText = `
                    position: fixed;
                    top: 20px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: linear-gradient(135deg, #ffd700, #ffed4e);
                    color: #000;
                    padding: 10px 20px;
                    border-radius: 25px;
                    font-weight: bold;
                    cursor: pointer;
                    z-index: 1000;
                    font-size: 16px;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                `;

                button.addEventListener('touchstart', function() {
                    ensureAudioContext();
                    button.style.display = 'none';
                });

                document.body.appendChild(button);

                // Hide button after 10 seconds
                setTimeout(() => {
                    if (button.parentNode) {
                        button.style.display = 'none';
                    }
                }, 10000);
            }
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            initializeDisplay();
            handleURLParams();

            // Connect to server for API commands
            connectToServer();

            // Try to enable audio immediately
            tryEnableAudioImmediately();

            // Create iOS audio unlock button if needed
            createAudioUnlockButton();

            // Default welcome sequence if no URL params
            if (!window.location.search) {
                setTimeout(() => {
                    updateLine(1, 'SPLIT FLAP', 0);
                    setTimeout(() => {
                        updateLine(1, 'BEREIT', 0);
                    }, 2000);
                }, 800);
            }
        });
    </script>
</body>
</html>
